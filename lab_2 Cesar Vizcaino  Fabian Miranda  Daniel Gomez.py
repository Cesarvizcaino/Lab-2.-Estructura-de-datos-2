# -*- coding: utf-8 -*-
"""Lab 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bzXXDdhqfH4u83ucD9KHT7smNlCqUjIY
"""

!pip install pyvis
!pip install graphviz

import pandas as pd
import folium as fl
from pyvis.network import Network
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from geopy.distance import geodesic

data = pd.read_csv("flights_final.csv")

data = data[~data[['Source Airport Code', 'Destination Airport Code']].duplicated(keep='first')].reset_index(drop=True)
data

data_origin = data[data.columns[:6]].drop_duplicates().reset_index(drop=True)
data_origin.columns = ['Code', 'Name', 'City', 'Country', 'Latitude', 'Longitude']
data_origin.head()

data_destination = data[data.columns[6:]].drop_duplicates().reset_index(drop=True)
data_destination.columns = ['Code', 'Name', 'City', 'Country', 'Latitude', 'Longitude']
data_destination.head()

airports = pd.concat([data_origin, data_destination]).drop_duplicates().reset_index(drop=True)
airports.head()

map = fl.Map()
lista = airports.values.tolist()
for row in lista:
    fl.Marker([row[-2], row[-1]], popup = ', '.join(row[:-2])).add_to(map)
map

G=nx.Graph()
datan = airports["Code"]
G.add_nodes_from(datan)# add nodes

for i in data.index:
     distance = geodesic((data['Destination Airport Latitude'][i], data['Destination Airport Longitude'][i]), (data['Source Airport Latitude'][i], data['Source Airport Longitude'][i])).kilometers
     G.add_edge(data['Source Airport Code'][i],data['Destination Airport Code'][i], length= 1000, weight = distance)

#1 Dado el codigo del aeropuerto

#Mostrar información
cod = "BAQ" # <---------------- Entrada

info = airports[airports['Code'] == cod]
info

class LL():
  def __init__(self, cod, dist):
    self.cod = cod
    self.dist = dist
    self.next = None
    self.prev = None

class Manager():
    def __init__(self):
      self.head = None
      self.tail = None
      self.len = 0

    def add(self, cod, dist):
      node = LL(cod, dist)
      if self.head is None:
        self.head = node
        self.tail = node
        self.len +=1
        return

      if self.len == 10:
        if node.dist > self.tail.dist:
          self.tail = self.tail.prev
          self.tail.next = None
          self.len-=1
        else:
          return
      if node.dist > self.head.dist:
        node.next = self.head
        self.head.prev = node
        self.head = node
        self.len +=1
        return
      nextNode = self.head
      found = True
      while(nextNode != None and found):
        if node.dist > nextNode.dist:
          found = False
        else:
          nextNode = nextNode.next
      if not found:
        node.prev = nextNode.prev
        node.next = nextNode
        node.prev.next = node
        nextNode.prev = node
      else:
        self.tail.next = node
        node.prev = self.tail
        self.tail = node
      self.len +=1

    def show(self):
      res = []
      act = self.head
      while act is not None:
        res.append([act.cod, act.dist])
        act = act.next
      return res

lejanos = Manager()
list1 = G.nodes
list2=[]
for i in list1:
  try:
    distancia = nx.dijkstra_path_length(G, cod, i)
  except:
    distance = float('inf')
  lejanos.add(i, distancia)
top10 = np.array(lejanos.show())

#Mostrar la información de los 10 aeropuertos cuyos caminos mínimos desde el vértice dado sean los más largos.
filas_top10 = airports[airports['Code'].isin(np.array(top10)[:, 0])].reset_index(drop=True)
filas_top10["Distance"] = top10[:, 1]
filas_top10

#2.

#NODO INICIAL - NODO FINAL

nodo1, nodo2 = "BAQ", "DJJ" # <---------- Entradas
try:
  camino = list(nx.dijkstra_path (G, nodo1, nodo2)) #camino minimo de un punto inicial y final
except:
  print(f"No existe un camino entre {nodo1} y {nodo2}")
camino

map = fl.Map()

airAux = airports[airports['Code'].isin(camino)]
air = airAux.set_index('Code').reindex(camino).reset_index()
lista = air.values.tolist()
for row in lista:
  fl.Marker([row[-2], row[-1]], popup = ', '.join(row[:-2])).add_to(map)
for i in range(0, len(lista)-1):
    fl.PolyLine([[lista[i][-2], lista[i][-1]],
                     [lista[i+1][-2], lista[i+1][-1]]]).add_to(map)
map